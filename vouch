#!/usr/bin/env python3
import argparse
import json
import sys
import ssl
import time
import math
import os
import re
from uuid import uuid4
from urllib.request import Request, urlopen
from urllib.error import HTTPError
from subprocess import check_output

def eprint(*args, **kwargs):
    return print(*args, file=sys.stderr, **kwargs)

stderr_isatty = os.isatty(sys.stderr.fileno())

class APIError(Exception):
    def __init__(self, response):
        self.error = response.get('error')
        if self.error and 'message' in self.error:
            super().__init__(f'API error: {self.error["message"]}')
        else:
            super().__init__(f'API error: {json.dumps(response)}')
        self.response = response

class Client:
    def __init__(self, keyFile, serviceUrl, insecure=False):
        self.keyFile = keyFile
        self.serviceUrl = serviceUrl
        self.insecure = insecure

    def call(self, method, params=None):
        requestId = str(uuid4())

        req = {
            'jsonrpc': '2.0',
            'id': requestId,
            'method': method,
        }
        if params is not None:
            req['params'] = params
        req = json.dumps(req).encode('utf-8')

        headers = {
            'Content-Type': 'application/json',
        }

        if self.keyFile:
            prefix = f'SSH {requestId} {math.floor(time.time())} '.encode('utf-8')
            signedMessage = prefix + req
            signature = check_output(['ssh-keygen',
                                      '-q',
                                      '-Y', 'sign',
                                      '-f', os.path.expanduser(self.keyFile),
                                      '-n', 'vouch.id+api@leastfixedpoint.com',
                                      '-'],
                                     input=signedMessage).replace(b'\n', b'')
            auth_header = prefix + signature
            headers['Authorization'] = auth_header

        context = ssl.create_default_context()
        if self.insecure:
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

        res = urlopen(Request(self.serviceUrl, data=req, headers=headers, method='POST'),
                      context=context)

        if res.status == 200:
            res = json.loads(res.read().decode('utf-8'))
            if 'result' in res:
                return res['result']
            else:
                raise APIError(res)
        elif res.status >= 200 and res.status <= 299:
            return None
        else:
            eprint(json.dumps({
                'http': res.status,
                'reason': res.reason,
            }))
            sys.exit(1)

def script(args, method, keyFile, params):
    return Client(keyFile, args.serviceUrl, insecure=args.insecure).call(method, params)

def _add_help_to(p, sp):
    h = sp.add_parser('help', help='Print help')
    h.set_defaults(handler=lambda args: p.print_help())

def defaultComment():
    import os
    import socket
    return os.getlogin() + '@' + socket.gethostname()

def progress_message(s):
    if stderr_isatty:
        eprint(f'\x0d\x1b[K\x1b[33;1m⋯\x1b[39m {s}\x1b[0m', end='')

def progress_detail(s):
    if stderr_isatty:
        eprint(s, end='')

def progress_ok():
    if stderr_isatty:
        eprint('\x0d\x1b[32;1m✔\x1b[0m')

def progress_fail(and_exit=True):
    if stderr_isatty:
        eprint('\x0d\x1b[31;1m❌\x1b[0m')
    if and_exit:
        sys.exit(1)

def progress_warning(s):
    if stderr_isatty:
        eprint(f'\x0d\x1b[K\x1b[31;1m⚠\x1b[33m {s}\x1b[0m')

def progress_check(result, and_exit=True):
    if result:
        progress_ok()
    else:
        progress_fail(and_exit)

def main(argv=sys.argv):
    app_name = os.path.basename(argv[0])
    argv = argv[1:]

    synopsis='''Interface to the vouch.id API.'''

    SP_ARGS = { 'formatter_class': argparse.ArgumentDefaultsHelpFormatter }

    parser = argparse.ArgumentParser(prog=app_name,
                                     description=synopsis,
                                     **SP_ARGS)

    parser.add_argument('--insecure', action='store_true', help=argparse.SUPPRESS)
    parser.add_argument('-s', '--service-url', dest='serviceUrl', default='https://vouch.id/')

    parser.set_defaults(handler=lambda args: parser.print_help())

    sp = parser.add_subparsers()

    _add_help_to(parser, sp)

    #---------------------------------------------------------------------------

    p = sp.add_parser('admin', help='Service administration', **SP_ARGS)
    admin_p = p
    p.set_defaults(handler=lambda args: admin_p.print_help())
    ssp = p.add_subparsers()
    _add_help_to(p, ssp)

    def invitePrincipal(args):
        import base64
        import urllib.parse
        res = script(args, 'invitePrincipal', args.keyFile, {
            'principal': args.principal,
            'expiry_seconds': args.expiry,
        })
        if args.invitation_code_only:
            print(res['invite_secret'])
        else:
            print(res['web_url'])
            print(res['app_url'])

    p = ssp.add_parser('invite', help='Invite principal', **SP_ARGS)
    p.add_argument('keyFile', metavar='adminKeyFile')
    p.add_argument('principal')
    p.add_argument('--expiry', metavar='SECONDS', type=int, default=86400,
                   help='Number of seconds the invitation should remain valid for')
    p.add_argument('--invitation-code-only', action='store_true',
                   help='Whether to print out only the invitation code or a full URL')
    p.set_defaults(handler=invitePrincipal)

    def deletePrincipal(args):
        print(json.dumps(script(args, 'deletePrincipal', args.keyFile, {
            'principal': args.principal,
        })['deleted']))

    p = ssp.add_parser('delete', help='Delete principal', **SP_ARGS)
    p.add_argument('keyFile', metavar='adminKeyFile')
    p.add_argument('principal')
    p.set_defaults(handler=deletePrincipal)

    #---------------------------------------------------------------------------

    p = sp.add_parser('machine', help='Tools for managing an SSH client machine', **SP_ARGS)
    machine_p = p
    p.set_defaults(handler=lambda args: machine_p.print_help())
    ssp = p.add_subparsers()
    _add_help_to(p, ssp)

    def registerMachine(args):
        print(script(args, 'registerMachine', args.keyFile, {
            'principal': args.principal,
            'comment': args.comment,
        })['rendezvous_code'])

    p = ssp.add_parser('register', help='Register client machine', **SP_ARGS)
    p.add_argument('-k', '--key', dest='keyFile', default='~/.ssh/id_ed25519')
    p.add_argument('principal')
    p.add_argument('--comment', default=defaultComment(), help='Comment to identify this machine and its key')
    p.set_defaults(handler=registerMachine)

    def getCertificate(args):
        cert = script(args, 'getCertificate', args.keyFile, {
            'principal': args.principal,
        })['certificate'] or ''
        if args.output is not None:
            if cert:
                with open(args.output, 'w') as f:
                    print(cert, file=f)
            else:
                sys.exit(1)
        else:
            print(cert)

    p = ssp.add_parser('certificate', help='Retrieve machine certificate', **SP_ARGS)
    p.add_argument('-k', '--key', dest='keyFile', default='~/.ssh/id_ed25519')
    p.add_argument('principal')
    p.add_argument('-o', '--output', metavar='FILENAME')
    p.set_defaults(handler=getCertificate)

    def login(args):
        keyFile = os.path.expanduser(args.keyFile)
        certFile = keyFile + '-cert.pub'

        progress_message('Checking key pair')
        if os.path.exists(keyFile):
            progress_ok()
        else:
            if args.dryRun:
                progress_detail(' — key pair not present')
                progress_fail()
            progress_message('Generating key pair')
            check_output(['ssh-keygen',
                          '-q',
                          '-t', 'ed25519',
                          '-C', args.comment,
                          '-N', '',
                          '-f', keyFile])
            progress_check(os.path.exists(keyFile))

        cert = None
        if os.path.exists(certFile):
            progress_message('Checking existing certificate')

            issuer_fingerprint = None
            if args.checkIssuer:
                progress_detail(' — fetching CA key')
                issuerKey = script(args, 'registerServer', None, {
                    'principal': args.principal,
                })['principal_key'] or ''
                if not issuerKey:
                    progress_detail(' — no CA key found')
                    progress_fail()
                issuer_fingerprint = check_output(['ssh-keygen', '-l', '-f', '-'],
                                                  encoding='utf-8',
                                                  input=issuerKey).split(' ')[1]

            with open(certFile, 'rt') as f:
                cert = f.read()

            lines = []
            try:
                lines = check_output(['ssh-keygen',
                                      '-L',
                                      '-f', certFile]).decode('utf-8').split('\n')
            except:
                pass

            signing_ca_re = re.compile(r'^        Signing CA: ED25519 (\S+).*$')
            validity_re = re.compile(r'^        Valid: (forever|from (\S+) to (\S+)|after (\S+)|before (\S+))$')
            for line in lines:

                if args.checkIssuer:
                    m = signing_ca_re.match(line)
                    if m:
                        if issuer_fingerprint != m.group(1):
                            progress_warning('Existing certificate issued by wrong CA')
                            cert = None

                m = validity_re.match(line)
                if m:
                    outcomes = []
                    now = time.localtime()
                    afterStr = m.group(2) or m.group(4)
                    if afterStr:
                        after = time.strptime(afterStr, '%Y-%m-%dT%H:%M:%S')
                        if now < after:
                            outcomes.append(f'not valid until {afterStr}')
                            cert = None
                    beforeStr = m.group(3) or m.group(5)
                    if beforeStr:
                        before = time.strptime(beforeStr, '%Y-%m-%dT%H:%M:%S')
                        if now >= before:
                            outcomes.append(f'expired at {beforeStr}')
                            cert = None
                    if outcomes:
                        progress_warning('Existing certificate ' + ' and '.join(outcomes))

            if cert is not None:
                progress_ok()

        if cert is None:
            if args.dryRun:
                progress_detail(' — no valid certificate present')
                progress_fail()
            progress_message('Fetching certificate')

            def get_rendezvous_code():
                try:
                    return script(args, 'registerMachine', args.keyFile, {
                        'principal': args.principal,
                        'comment': args.comment,
                    })['rendezvous_code']
                except APIError as exn:
                    if exn.error.get('data') == 'MACHINE_ALREADY_REGISTERED':
                        return None
                    else:
                        progress_fail(False)
                        raise

            def get_certificate():
                try:
                    return script(args, 'getCertificate', args.keyFile, {
                        'principal': args.principal,
                    })['certificate'] or ''
                except APIError as exn:
                    if exn.error.get('data') == 'MACHINE_NOT_FOUND':
                        return False
                    else:
                        progress_fail(False)
                        raise

            old_rendezvous_code = None
            new_rendezvous_code = get_rendezvous_code()

            while True:
                if new_rendezvous_code != None:
                    if old_rendezvous_code != new_rendezvous_code:
                        progress_message('Add machine in app. Rendezvous code: ' + new_rendezvous_code)
                        old_rendezvous_code = new_rendezvous_code
                    time.sleep(5)
                    new_rendezvous_code = get_rendezvous_code()
                    continue

                cert = get_certificate()
                if cert == False:
                    continue
                if cert:
                    break
                progress_message('Waiting for certificate to issue')
                time.sleep(5)

            with open(certFile, 'wt') as f:
                f.write(cert)

            progress_ok()

        if not os.getenv('SSH_AUTH_SOCK'):
            progress_warning('ssh-agent not running, cannot add certificate to ssh-agent')
        else:
            progress_message('Adding certificate to ssh-agent')
            check_output(['ssh-add', '-q', keyFile])
            progress_ok()

    def add_login_args(p):
        p.add_argument('-k', '--key', dest='keyFile', default='~/.ssh/id_ed25519')
        p.add_argument('--comment', default=defaultComment(), help='Comment to identify this machine and its key')
        p.add_argument('--no-check-issuer', dest='checkIssuer', action='store_false')
        p.add_argument('principal')

    p = ssp.add_parser('login', help='Run through all the steps to ensure a certificate is available', **SP_ARGS)
    p.add_argument('-n', '--dry-run', dest='dryRun', action='store_true',
                   help='Report on certificate status without doing anything')
    add_login_args(p)
    p.set_defaults(handler=login)

    #---------------------------------------------------------------------------

    p = sp.add_parser('principal', help='Tools for managing a principal account', **SP_ARGS)
    principal_p = p
    p.set_defaults(handler=lambda args: principal_p.print_help())
    ssp = p.add_subparsers()
    _add_help_to(p, ssp)

    p = ssp.add_parser('machine', help='Manage registered machines', **SP_ARGS)
    principal_machine_p = p
    p.set_defaults(handler=lambda args: principal_machine_p.print_help())
    sssp = p.add_subparsers()
    _add_help_to(p, sssp)

    def deregisterMachine(args):
        print(json.dumps(script(args, 'deregisterMachine', args.keyFile, {
            'machine': args.machineKey,
        })['deleted']))

    p = sssp.add_parser('deregister', help='Deregister a machine', **SP_ARGS)
    p.add_argument('keyFile', metavar='principalKeyFile')
    p.add_argument('machineKey')
    p.set_defaults(handler=deregisterMachine)

    def setMachine(args):
        script(args, 'setMachine', args.keyFile, {
            'machine': args.machineKey,
            'comment': args.comment,
            'certificate': None if args.certificate == '' else args.certificate,
        })

    p = sssp.add_parser('set', help='Update a registered machine', **SP_ARGS)
    p.add_argument('keyFile', metavar='principalKeyFile')
    p.add_argument('machineKey')
    p.add_argument('comment')
    p.add_argument('certificate', default='', nargs='?')
    p.set_defaults(handler=setMachine)

    def listMachines(args):
        if not args.json:
            print('comment\tcert_present\tregistration_time\trequest_time\tpub')
        for u in script(args, 'listMachines', args.keyFile, {})['machines']:
            if args.json:
                print(json.dumps(u))
            else:
                print(f'{u["comment"]}\t{"Y" if u["certificate"] else "N"}\t{u["registration_time"] or ""}\t{u["request_time"] or ""}\t{u["machine"]}')

    p = sssp.add_parser('list', help='List registered machines', **SP_ARGS)
    p.add_argument('keyFile', metavar='principalKeyFile')
    p.add_argument('--json', action='store_true')
    p.set_defaults(handler=listMachines)

    def lookupRegistration(args):
        res = script(args, 'lookupRegistration', args.keyFile, {
            'rendezvous_code': args.rendezvousCode,
        })
        if res['found']:
            print(res['machine'] + ((' ' + res['comment']) if res['comment'] else ''))

    p = sssp.add_parser('lookup', help='Look up outstanding machine registration', **SP_ARGS)
    p.add_argument('keyFile', metavar='principalKeyFile')
    p.add_argument('rendezvousCode')
    p.set_defaults(handler=lookupRegistration)

    p = ssp.add_parser('csr', help='Manage outstanding CSRs', **SP_ARGS)
    principal_csr_p = p
    p.set_defaults(handler=lambda args: principal_csr_p.print_help())
    sssp = p.add_subparsers()
    _add_help_to(p, sssp)

    def getCertificateRequests(args):
        for req in script(args, 'getCertificateRequests', args.keyFile, {})['requests']:
            if args.json:
                print(json.dumps(req))
            else:
                print(req['machine'] + ((' ' + req['comment']) if req['comment'] else ''))

    p = sssp.add_parser('list', help='List outstanding CSRs', **SP_ARGS)
    p.add_argument('keyFile', metavar='principalKeyFile')
    p.add_argument('--json', action='store_true')
    p.set_defaults(handler=getCertificateRequests)

    p = ssp.add_parser('account', help='Manage a principal\'s account', **SP_ARGS)
    principal_account_p = p
    p.set_defaults(handler=lambda args: principal_account_p.print_help())
    sssp = p.add_subparsers()
    _add_help_to(p, sssp)

    def registerPrincipal(args):
        script(args, 'registerPrincipal', args.keyFile, {
            'invite_secret': args.inviteSecret,
        })

    p = sssp.add_parser('register', help='Respond to an registration invitation', **SP_ARGS)
    p.add_argument('keyFile', metavar='principalKeyFile')
    p.add_argument('inviteSecret')
    p.set_defaults(handler=registerPrincipal)

    def reregisterPrincipal(args):
        script(args, 'reregisterPrincipal', args.keyFile, {
            'principal_key': None if args.newPublicKeyFile == '-' else open(args.newPublicKeyFile, 'r').read(),
        })

    p = sssp.add_parser('reregister', help='Change principal key', **SP_ARGS)
    p.add_argument('keyFile', metavar='oldPrincipalKeyFile')
    p.add_argument('newPublicKeyFile', help='Name of new principal public key, or "-" to DELETE ACCOUNT')
    p.set_defaults(handler=reregisterPrincipal)

    #---------------------------------------------------------------------------

    p = sp.add_parser('server', help='Tools for managing an SSH server', **SP_ARGS)
    server_p = p
    p.set_defaults(handler=lambda args: server_p.print_help())
    ssp = p.add_subparsers()
    _add_help_to(p, ssp)

    def registerServer(args):
        print(script(args, 'registerServer', None, {
            'principal': args.principal,
        })['principal_key'] or '')

    p = ssp.add_parser('ca', help='Retrive public key for a principal\'s CA', **SP_ARGS)
    p.add_argument('principal')
    p.set_defaults(handler=registerServer)

    #---------------------------------------------------------------------------

    def magic(args):
        login(args)
        os.execvp('nc', ['nc', args.host, str(args.port)])

    p = sp.add_parser('magic', help='ProxyCommand SSH connection', **SP_ARGS)
    add_login_args(p)
    p.add_argument('host')
    p.add_argument('port', type=int)
    p.set_defaults(handler=magic)

    #---------------------------------------------------------------------------

    args = parser.parse_args(argv)
    try:
        args.handler(args)
    except HTTPError as exn:
        eprint(json.dumps({
            'http': exn.code,
            'reason': exn.reason,
        }))
        sys.exit(1)
    except Exception as exn:
        eprint(exn)
        sys.exit(1)

if __name__ == "__main__":
    main(sys.argv)
