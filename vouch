#!/usr/bin/env python3
import argparse
import base64
import json
import math
import os
import re
import socket
import ssl
import struct
import sys
import time
from uuid import uuid4
from urllib.request import Request, urlopen
from urllib.error import HTTPError
from subprocess import check_output

def eprint(*args, **kwargs):
    return print(*args, file=sys.stderr, **kwargs)

stderr_isatty = os.isatty(sys.stderr.fileno())

class APIError(Exception):
    def __init__(self, response):
        self.error = response.get('error')
        if self.error and 'message' in self.error:
            super().__init__(f'API error: {self.error["message"]}')
        else:
            super().__init__(f'API error: {json.dumps(response)}')
        self.response = response

class Client:
    def __init__(self, keyFile, serviceUrl, insecure=False):
        self.keyFile = keyFile
        self.serviceUrl = serviceUrl
        self.insecure = insecure

    def call(self, method, params=None):
        requestId = str(uuid4())

        req = {
            'jsonrpc': '2.0',
            'id': requestId,
            'method': method,
        }
        if params is not None:
            req['params'] = params
        req = json.dumps(req).encode('utf-8')

        headers = {
            'Content-Type': 'application/json',
        }

        if self.keyFile:
            prefix = f'SSH {requestId} {math.floor(time.time())} '.encode('utf-8')
            signedMessage = prefix + req
            signature = check_output(['ssh-keygen',
                                      '-q',
                                      '-Y', 'sign',
                                      '-f', os.path.expanduser(self.keyFile),
                                      '-n', 'api@vouch.id',
                                      '-'],
                                     input=signedMessage).replace(b'\n', b'')
            auth_header = prefix + signature
            headers['Authorization'] = auth_header

        context = ssl.create_default_context()
        if self.insecure:
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

        res = urlopen(Request(self.serviceUrl, data=req, headers=headers, method='POST'),
                      context=context)

        if res.status == 200:
            res = json.loads(res.read().decode('utf-8'))
            if 'result' in res:
                return res['result']
            else:
                raise APIError(res)
        elif res.status >= 200 and res.status <= 299:
            return None
        else:
            eprint(json.dumps({
                'http': res.status,
                'reason': res.reason,
            }))
            sys.exit(1)

def script(args, method, keyFile, params):
    return Client(keyFile, args.serviceUrl, insecure=args.insecure).call(method, params)

def _add_help_to(p, sp):
    h = sp.add_parser('help', help='Print help')
    h.set_defaults(handler=lambda args: p.print_help())

def defaultComment():
    import os
    import socket
    return os.getlogin() + '@' + socket.gethostname()

def progress_message(s):
    if stderr_isatty:
        eprint(f'\x0d\x1b[K\x1b[33;1mâ‹¯\x1b[39m {s}\x1b[0m', end='')

def progress_detail(s):
    if stderr_isatty:
        eprint(s, end='')

def progress_ok():
    if stderr_isatty:
        eprint('\x0d\x1b[32;1mâœ”\x1b[0m')

def progress_fail(and_exit=True):
    if stderr_isatty:
        eprint('\x0d\x1b[31;1mâŒ\x1b[0m')
    if and_exit:
        sys.exit(1)

def progress_warning(s):
    if stderr_isatty:
        eprint(f'\x0d\x1b[K\x1b[31;1mâš \x1b[33m {s}\x1b[0m')

def progress_info(s):
    if stderr_isatty:
        eprint(f'\x0d\x1b[K\x1b[34;1mðŸ›ˆ\x1b[39m {s}\x1b[0m')

def progress_check(result, and_exit=True):
    if result:
        progress_ok()
    else:
        progress_fail(and_exit)

## SSH wire formatting

def parse_chunk(length, bs):
    if len(bs) < length: raise ValueError('Packet too short')
    return (bs[:length], bs[length:])

def parse_expected(expected, bs, msg=None):
    if not bs.startswith(expected):
        raise ValueError(msg or ('Missing expected text ' + repr(expected)))
    return bs[len(expected):]

def parse_int(bs):
    if len(bs) < 4: raise ValueError('Packet too short')
    (val,) = struct.unpack('>I', bs[:4])
    return (val, bs[4:])

def parse_long(bs):
    if len(bs) < 8: raise ValueError('Packet too short')
    (val,) = struct.unpack('>Q', bs[:8])
    return (val, bs[8:])

def parse_byte(bs):
    if len(bs) < 1: raise ValueError('Packet too short')
    (val,) = struct.unpack('>B', bs[:1])
    return (val, bs[1:])

def parse_str(bs):
    (length, bs) = parse_int(bs)
    if len(bs) < length: raise ValueError('Packet too short')
    return (bs[:length], bs[length:])

def parse_expected_str(expected, bs, msg=None):
    (actual, bs) = parse_str(bs)
    if actual != expected: raise ValueError(msg or ('Missing expected text ' + repr(expected)))
    return bs

def parse_end(bs):
    if bs != b'': raise ValueError('Unexpected bytes at end of packet')

def format_int(i): return struct.pack('>I', i)
def format_byte(b): return struct.pack('>B', b)
def format_str(bs): return format_int(len(bs)) + bs

class SshAgent:
    def __init__(self, socket_path=None):
        if socket_path is None:
            socket_path = os.environ.get('SSH_AUTH_SOCK', None)

        self.socket_path = socket_path

        if socket_path:
            try:
                self._socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                self._socket.connect(socket_path)
            except socket.error:
                if self._socket:
                    self._socket.close()
                self._socket = None
        else:
            self._socket = None

    def __del__(self):
        if self._socket:
            self._socket.close()
            self._socket = None

    def _send(self, packet):
        self._socket.sendall(format_str(packet))

    def _readbytes(self, count):
        bs = b''
        while count > 0:
            chunk = self._socket.recv(count)
            count = count - len(chunk)
            bs = bs + chunk
        return memoryview(bs)

    def _recv(self):
        (length,) = struct.unpack('>I', self._readbytes(4))
        bs = self._readbytes(length)
        return bs

    def _readreply(self):
        return parse_byte(self._recv())

    def list_identities(self):
        if not self._socket:
            return []
        self._send(bytes([11])) # SSH_AGENTC_REQUEST_IDENTITIES
        (packet_type, blob) = self._readreply()
        assert packet_type == 12 # SSH_AGENT_IDENTITIES_ANSWER
        (nkeys, blob) = parse_int(blob)

        result = []
        for i in range(nkeys):
            (keyblob, blob) = parse_str(blob)
            (comment, blob) = parse_str(blob)
            keytype = bytes(parse_str(keyblob)[0])
            result.append((keytype, bytes(keyblob), bytes(comment).decode('utf-8')))

        parse_end(blob)
        return result

    def _readsuccess(self):
        (packet_type, blob) = self._readreply()
        assert packet_type == 6 # SSH_AGENT_SUCCESS
        parse_end(blob)

    def add_identity(self, key_type, contents, comment):
        self._send(bytes([17]) + format_str(key_type) + contents + format_str(comment))
        self._readsuccess()

    def remove_identity(self, key_blob):
        self._send(bytes([18]) + format_str(key_blob))
        self._readsuccess()

class Ed25519PublicKey:
    MAGIC = b'ssh-ed25519'

    def __init__(self):
        self.blob = None
        self.public_key_bytes = None

    def load(self, blob):
        self.blob = blob
        blob = parse_expected_str(Ed25519PublicKey.MAGIC, blob, 'Non-ED25519 keys not yet supported')
        (self.public_key_bytes, blob) = parse_str(blob)
        parse_end(blob)
        return self

    def load_from_bytes(self, bs):
        self.blob = None
        self.public_key_bytes = bs
        return self

    def __eq__(self, other):
        return self.public_key_bytes == other.public_key_bytes

class Ed25519SecretKey:
    MAGIC = b'ssh-ed25519'

    def __init__(self):
        self.blob = None
        self.public_key = None
        self.secret_key_seed = None

    def load(self, blob):
        orig_blob = blob

        (check1, blob) = parse_int(blob)
        (check2, blob) = parse_int(blob)
        if check1 != check2:
            raise ValueError('Private key decryption failed')

        blob = parse_expected_str(Ed25519SecretKey.MAGIC, blob, 'Non-ED25519 keys not yet supported')

        (public_key_bytes, blob) = parse_str(blob)
        self.public_key = Ed25519PublicKey().load_from_bytes(public_key_bytes)
        (sk, blob) = parse_str(blob)
        self.secret_key_seed = sk[:32]

        (_comment, blob) = parse_str(blob)
        self.blob = orig_blob[:-len(blob)]

        # Padding
        if len(blob) >= 16:
            raise ValueError('Invalid private key file')
        for (idx, b) in enumerate(blob, 1):
            if idx != b:
                raise ValueError('Invalid private key file')

        return self

    def __eq__(self, other):
        return self.secret_key_seed == other.secret_key_seed

class Ed25519Certificate:
    MAGIC = b'ssh-ed25519-cert-v01@openssh.com'

    def __init__(self):
        self.blob = None
        self.nonce = None

    def load(self, blob):
        self.blob = blob
        blob = parse_expected_str(Ed25519Certificate.MAGIC, blob)
        (self.nonce, blob) = parse_str(blob)
        (signed_public_key_bytes, blob) = parse_str(blob)
        self.signed_public_key = Ed25519PublicKey().load_from_bytes(signed_public_key_bytes)
        (self.serial, blob) = parse_long(blob)
        (self.cert_type, blob) = parse_int(blob)
        (self.key_id, blob) = parse_str(blob)
        (principals, blob) = parse_str(blob)
        self.valid_principals = []
        while principals:
            (p, principals) = parse_str(principals)
            self.valid_principals.append(p)
        (self.valid_after, blob) = parse_long(blob)
        (self.valid_before, blob) = parse_long(blob)
        (self.critical_options_blob, blob) = parse_str(blob)
        (self.extensions_blob, blob) = parse_str(blob)
        (self.reserved, blob) = parse_str(blob)
        (issuer_public_key_bytes, blob) = parse_str(blob)
        self.issuer_public_key = Ed25519PublicKey().load(issuer_public_key_bytes)
        (self.signature_blob, blob) = parse_str(blob)
        return self

    def validity_errors(self, now=None):
        if now is None:
            now = time.time()

        errors = []

        if now < self.valid_after:
            t = time.localtime(self.valid_after)
            errors.append(f'it is not valid until {time.strftime("%Y-%m-%d %H:%M:%S", t)}')

        if now >= self.valid_before:
            t = time.localtime(self.valid_before)
            errors.append(f'it expired at {time.strftime("%Y-%m-%d %H:%M:%S", t)}')

        return errors

def decode_secret_key(text):
    PREFIX = '-----BEGIN OPENSSH PRIVATE KEY-----'
    SUFFIX = '-----END OPENSSH PRIVATE KEY-----'
    text = text.replace('\n', '')
    if not text.startswith(PREFIX) or not text.endswith(SUFFIX):
        raise ValueError('Invalid private key file')
    text = text[len(PREFIX):-len(SUFFIX)]
    blob = base64.b64decode(text)
    blob = parse_expected(b'openssh-key-v1\0', blob, 'Invalid private key file')
    blob = parse_expected_str(b'none', blob, 'Passphrases not yet supported') # cipher
    blob = parse_expected_str(b'none', blob, 'Passphrases not yet supported') # kd
    blob = parse_expected_str(b'', blob, 'Invalid private key file') # salt

    (nkeys, blob) = parse_int(blob)
    if nkeys != 1:
        raise ValueError('Private key file with more than one keypair not yet supported')

    (pubkey_blob, blob) = parse_str(blob)
    public_key = Ed25519PublicKey().load(pubkey_blob)

    (seckey_blob, blob) = parse_str(blob)
    secret_key = Ed25519SecretKey().load(seckey_blob)

    if secret_key.public_key != public_key:
        raise ValueError('Private key does not match public key')

    return secret_key

def main(argv=sys.argv):
    app_name = os.path.basename(argv[0])
    argv = argv[1:]

    synopsis='''Interface to the vouch.id API.'''

    SP_ARGS = { 'formatter_class': argparse.ArgumentDefaultsHelpFormatter }

    parser = argparse.ArgumentParser(prog=app_name,
                                     description=synopsis,
                                     **SP_ARGS)

    parser.add_argument('--insecure', action='store_true', help=argparse.SUPPRESS)
    parser.add_argument('-s', '--service-url', dest='serviceUrl', default='https://vouch.id/')

    parser.set_defaults(handler=lambda args: parser.print_help())

    sp = parser.add_subparsers()

    _add_help_to(parser, sp)

    #---------------------------------------------------------------------------

    p = sp.add_parser('admin', help='Service administration', **SP_ARGS)
    admin_p = p
    p.set_defaults(handler=lambda args: admin_p.print_help())
    ssp = p.add_subparsers()
    _add_help_to(p, ssp)

    def invitePrincipal(args):
        res = script(args, 'invitePrincipal', args.keyFile, {
            'principal': args.principal,
            'expiry_seconds': args.expiry,
        })
        if args.invitation_code_only:
            print(res['invite_secret'])
        else:
            print(res['web_url'])
            print(res['app_url'])

    p = ssp.add_parser('invite', help='Invite principal', **SP_ARGS)
    p.add_argument('keyFile', metavar='adminKeyFile')
    p.add_argument('principal')
    p.add_argument('--expiry', metavar='SECONDS', type=int, default=86400,
                   help='Number of seconds the invitation should remain valid for')
    p.add_argument('--invitation-code-only', action='store_true',
                   help='Whether to print out only the invitation code or a full URL')
    p.set_defaults(handler=invitePrincipal)

    def deletePrincipal(args):
        print(json.dumps(script(args, 'deletePrincipal', args.keyFile, {
            'principal': args.principal,
        })['deleted']))

    p = ssp.add_parser('delete', help='Delete principal', **SP_ARGS)
    p.add_argument('keyFile', metavar='adminKeyFile')
    p.add_argument('principal')
    p.set_defaults(handler=deletePrincipal)

    #---------------------------------------------------------------------------

    p = sp.add_parser('machine', help='Tools for managing an SSH client machine', **SP_ARGS)
    machine_p = p
    p.set_defaults(handler=lambda args: machine_p.print_help())
    ssp = p.add_subparsers()
    _add_help_to(p, ssp)

    def registerMachine(args):
        print(script(args, 'registerMachine', args.keyFile, {
            'principal': args.principal,
            'comment': args.comment,
        })['rendezvous_code'])

    p = ssp.add_parser('register', help='Register client machine', **SP_ARGS)
    p.add_argument('-k', '--key', dest='keyFile', default='~/.ssh/id_ed25519')
    p.add_argument('principal')
    p.add_argument('--comment', default=defaultComment(), help='Comment to identify this machine and its key')
    p.set_defaults(handler=registerMachine)

    def getCertificate(args):
        cert = script(args, 'getCertificate', args.keyFile, {
            'principal': args.principal,
        })['certificate'] or ''
        if args.output is not None:
            if cert:
                with open(args.output, 'w') as f:
                    print(cert, file=f)
            else:
                sys.exit(1)
        else:
            print(cert)

    p = ssp.add_parser('certificate', help='Retrieve machine certificate', **SP_ARGS)
    p.add_argument('-k', '--key', dest='keyFile', default='~/.ssh/id_ed25519')
    p.add_argument('principal')
    p.add_argument('-o', '--output', metavar='FILENAME')
    p.set_defaults(handler=getCertificate)

    def login(args):
        keyFile = os.path.expanduser(args.keyFile)
        certFile = keyFile + '-cert.pub'

        agent = SshAgent()
        if not agent.socket_path:
            progress_warning('ssh-agent not running or not configured')
            if args.saveCertificate:
                progress_info('will only save certificate to disk')
            else:
                progress_message('no ssh-agent, cannot load certificates')
                progress_fail()

        progress_message('Checking key pair')
        if os.path.exists(keyFile):
            progress_ok()
        else:
            if args.dryRun:
                progress_detail(' â€” key pair not present')
                progress_fail()
            progress_message('Generating key pair')
            check_output(['ssh-keygen',
                          '-q',
                          '-t', 'ed25519',
                          '-C', args.comment,
                          '-N', '',
                          '-f', keyFile])
            progress_check(os.path.exists(keyFile))

        with open(keyFile, 'rt') as f:
            secret_key = decode_secret_key(f.read())

        issuerKey = None
        if args.checkIssuer:
            progress_detail(' â€” fetching CA key')
            issuerKeyStr = script(args, 'registerServer', None, {
                'principal': args.principal,
            })['principal_key'] or ''
            if not issuerKeyStr:
                progress_detail(' â€” no CA key found')
                progress_fail()
            issuerKey = Ed25519PublicKey().load(base64.b64decode(issuerKeyStr.split(' ')[1]))

        progress_message('Checking existing certificates')

        to_remove = []
        chosen = None

        for (keytype, keybytes, keycomment) in agent.list_identities():
            if keytype != Ed25519Certificate.MAGIC:
                continue

            candidate = Ed25519Certificate().load(keybytes)

            if candidate.signed_public_key != secret_key.public_key:
                continue

            if args.checkIssuer:
                if candidate.issuer_public_key != issuerKey:
                    to_remove.append((candidate, 'it was issued by a different CA'))
                    continue

            errors = candidate.validity_errors()
            if errors:
                to_remove.append((candidate, ' and '.join(errors)))
                continue

            if chosen is None:
                chosen = candidate
            else:
                if candidate.valid_before > chosen.valid_before:
                    to_remove.append(chosen)
                    chosen = candidate
                else:
                    to_remove.append(candidate)

        progress_check(chosen is not None, and_exit=False)

        for (cert, reason) in to_remove:
            progress_info('Removing an existing certificate because ' + reason)
            if not args.dryRun:
                agent.remove_identity(cert.blob)

        if chosen is None:
            if args.dryRun:
                progress_info('Dry run, not requesting a certificate')
                return

            progress_message('Fetching certificate')

            def get_rendezvous_code():
                try:
                    return script(args, 'registerMachine', args.keyFile, {
                        'principal': args.principal,
                        'comment': args.comment,
                    })['rendezvous_code']
                except APIError as exn:
                    if exn.error.get('data') == 'MACHINE_ALREADY_REGISTERED':
                        return None
                    else:
                        progress_fail(False)
                        raise

            def get_certificate():
                try:
                    return script(args, 'getCertificate', args.keyFile, {
                        'principal': args.principal,
                    })['certificate'] or ''
                except APIError as exn:
                    if exn.error.get('data') == 'MACHINE_NOT_FOUND':
                        return False
                    else:
                        progress_fail(False)
                        raise

            old_rendezvous_code = None
            new_rendezvous_code = get_rendezvous_code()

            while True:
                if new_rendezvous_code != None:
                    if old_rendezvous_code != new_rendezvous_code:
                        progress_message('Add machine in app. Rendezvous code: ' + new_rendezvous_code)
                        old_rendezvous_code = new_rendezvous_code
                    time.sleep(5)
                    new_rendezvous_code = get_rendezvous_code()
                    continue

                cert_str = get_certificate()
                if cert_str == False:
                    continue
                if cert_str:
                    chosen = Ed25519Certificate().load(base64.b64decode(cert_str.split(' ')[1]))
                    break
                progress_message('Waiting for certificate to issue')
                time.sleep(5)

            progress_ok()

            if args.saveCertificate:
                progress_message('Writing certificate to disk')
                with open(certFile, 'wt') as f:
                    f.write(cert_str)
                progress_ok()

            progress_message('Adding certificate to ssh-agent')
            agent.add_identity(Ed25519Certificate.MAGIC,
                               (format_str(chosen.blob) +
                                format_str(secret_key.public_key.public_key_bytes) +
                                format_str(secret_key.secret_key_seed +
                                           secret_key.public_key.public_key_bytes)),
                               b'')
            progress_ok()

    def add_login_args(p):
        p.add_argument('-k', '--key', dest='keyFile', default='~/.ssh/id_ed25519')
        p.add_argument('--comment', default=defaultComment(), help='Comment to identify this machine and its key')
        p.add_argument('--no-check-issuer', dest='checkIssuer', action='store_false')
        p.add_argument('--save-certificate', dest='saveCertificate', action='store_true')
        p.add_argument('-n', '--dry-run', dest='dryRun', action='store_true',
                       help='Report on certificate status without doing anything')
        p.add_argument('principal')

    p = ssp.add_parser('login', help='Run through all the steps to ensure a certificate is available', **SP_ARGS)
    add_login_args(p)
    p.set_defaults(handler=login)

    #---------------------------------------------------------------------------

    p = sp.add_parser('principal', help='Tools for managing a principal account', **SP_ARGS)
    principal_p = p
    p.set_defaults(handler=lambda args: principal_p.print_help())
    ssp = p.add_subparsers()
    _add_help_to(p, ssp)

    p = ssp.add_parser('machine', help='Manage registered machines', **SP_ARGS)
    principal_machine_p = p
    p.set_defaults(handler=lambda args: principal_machine_p.print_help())
    sssp = p.add_subparsers()
    _add_help_to(p, sssp)

    def deregisterMachine(args):
        print(json.dumps(script(args, 'deregisterMachine', args.keyFile, {
            'machine': args.machineKey,
        })['deleted']))

    p = sssp.add_parser('deregister', help='Deregister a machine', **SP_ARGS)
    p.add_argument('keyFile', metavar='principalKeyFile')
    p.add_argument('machineKey')
    p.set_defaults(handler=deregisterMachine)

    def setMachine(args):
        script(args, 'setMachine', args.keyFile, {
            'machine': args.machineKey,
            'comment': args.comment,
            'certificate': None if args.certificate == '' else args.certificate,
        })

    p = sssp.add_parser('set', help='Update a registered machine', **SP_ARGS)
    p.add_argument('keyFile', metavar='principalKeyFile')
    p.add_argument('machineKey')
    p.add_argument('comment')
    p.add_argument('certificate', default='', nargs='?')
    p.set_defaults(handler=setMachine)

    def listMachines(args):
        if not args.json:
            print('comment\tcert_present\tregistration_time\trequest_time\tpub')
        for u in script(args, 'listMachines', args.keyFile, {})['machines']:
            if args.json:
                print(json.dumps(u))
            else:
                print(f'{u["comment"]}\t{"Y" if u["certificate"] else "N"}\t{u["registration_time"] or ""}\t{u["request_time"] or ""}\t{u["machine"]}')

    p = sssp.add_parser('list', help='List registered machines', **SP_ARGS)
    p.add_argument('keyFile', metavar='principalKeyFile')
    p.add_argument('--json', action='store_true')
    p.set_defaults(handler=listMachines)

    def lookupRegistration(args):
        res = script(args, 'lookupRegistration', args.keyFile, {
            'rendezvous_code': args.rendezvousCode,
        })
        if res['found']:
            print(res['machine'] + ((' ' + res['comment']) if res['comment'] else ''))

    p = sssp.add_parser('lookup', help='Look up outstanding machine registration', **SP_ARGS)
    p.add_argument('keyFile', metavar='principalKeyFile')
    p.add_argument('rendezvousCode')
    p.set_defaults(handler=lookupRegistration)

    p = ssp.add_parser('csr', help='Manage outstanding CSRs', **SP_ARGS)
    principal_csr_p = p
    p.set_defaults(handler=lambda args: principal_csr_p.print_help())
    sssp = p.add_subparsers()
    _add_help_to(p, sssp)

    def getCertificateRequests(args):
        for req in script(args, 'getCertificateRequests', args.keyFile, {})['requests']:
            if args.json:
                print(json.dumps(req))
            else:
                print(req['machine'] + ((' ' + req['comment']) if req['comment'] else ''))

    p = sssp.add_parser('list', help='List outstanding CSRs', **SP_ARGS)
    p.add_argument('keyFile', metavar='principalKeyFile')
    p.add_argument('--json', action='store_true')
    p.set_defaults(handler=getCertificateRequests)

    p = ssp.add_parser('account', help='Manage a principal\'s account', **SP_ARGS)
    principal_account_p = p
    p.set_defaults(handler=lambda args: principal_account_p.print_help())
    sssp = p.add_subparsers()
    _add_help_to(p, sssp)

    def registerPrincipal(args):
        script(args, 'registerPrincipal', args.keyFile, {
            'invite_secret': args.inviteSecret,
        })

    p = sssp.add_parser('register', help='Respond to an registration invitation', **SP_ARGS)
    p.add_argument('keyFile', metavar='principalKeyFile')
    p.add_argument('inviteSecret')
    p.set_defaults(handler=registerPrincipal)

    def reregisterPrincipal(args):
        script(args, 'reregisterPrincipal', args.keyFile, {
            'principal_key': None if args.newPublicKeyFile == '-' else open(args.newPublicKeyFile, 'r').read(),
        })

    p = sssp.add_parser('reregister', help='Change principal key', **SP_ARGS)
    p.add_argument('keyFile', metavar='oldPrincipalKeyFile')
    p.add_argument('newPublicKeyFile', help='Name of new principal public key, or "-" to DELETE ACCOUNT')
    p.set_defaults(handler=reregisterPrincipal)

    #---------------------------------------------------------------------------

    p = sp.add_parser('server', help='Tools for managing an SSH server', **SP_ARGS)
    server_p = p
    p.set_defaults(handler=lambda args: server_p.print_help())
    ssp = p.add_subparsers()
    _add_help_to(p, ssp)

    def registerServer(args):
        print(script(args, 'registerServer', None, {
            'principal': args.principal,
        })['principal_key'] or '')

    p = ssp.add_parser('ca', help='Retrive public key for a principal\'s CA', **SP_ARGS)
    p.add_argument('principal')
    p.set_defaults(handler=registerServer)

    #---------------------------------------------------------------------------

    def magic(args):
        login(args)
        os.execvp('nc', ['nc', args.host, str(args.port)])

    p = sp.add_parser('magic', help='ProxyCommand SSH connection', **SP_ARGS)
    add_login_args(p)
    p.add_argument('host')
    p.add_argument('port', type=int)
    p.set_defaults(handler=magic)

    #---------------------------------------------------------------------------

    args = parser.parse_args(argv)
    try:
        args.handler(args)
    except HTTPError as exn:
        eprint(json.dumps({
            'http': exn.code,
            'reason': exn.reason,
        }))
        sys.exit(1)
    except Exception as exn:
        eprint(exn)
        sys.exit(1)

if __name__ == "__main__":
    main(sys.argv)
